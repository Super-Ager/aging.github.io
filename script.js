// Configuration
// const IMAGE_FOLDER = 'protein_images';
const IMAGE_FOLDER = 'https://proteinaging.oss-rg-china-mainland.aliyuncs.com'; // 或自定义域名
const DEFAULT_IMAGE = 'GDF15_seq.4374.45';
const DEBOUNCE_DELAY = 300; // milliseconds

// State
let allProteins = [];
let filteredProteins = [];
let selectedIndex = -1;
let searchTimeout = null;

// DOM elements
const searchInput = document.getElementById('searchInput');
const searchResults = document.getElementById('searchResults');
const proteinImage = document.getElementById('proteinImage');
const loadingIndicator = document.getElementById('loadingIndicator');
const errorMessage = document.getElementById('errorMessage');
const imageInfo = document.getElementById('imageInfo');

// Initialize
document.addEventListener('DOMContentLoaded', () => {
    setupEventListeners();
    initializeProteins().then(() => {
        // Set default value in search box
        searchInput.value = DEFAULT_IMAGE;
        // Show all proteins in dropdown initially
        filteredProteins = [...allProteins];
        displayResults();
        loadDefaultImage();
    });
});

// Fetch all protein filenames
async function initializeProteins() {
    try {
        // Try to fetch a list file first
        try {
            // const response = await fetch(`${IMAGE_FOLDER}/list.json`);
            const response = await fetch(`list.json`);
            if (response.ok) {
                allProteins = await response.json();
                console.log(`Loaded ${allProteins.length} proteins from list.json`);
            } else {
                // Fallback: generate list from common patterns
                console.warn('list.json not found, using fallback list. Please run generate-list.js or generate-list.py');
                allProteins = generateProteinList();
            }
        } catch (e) {
            // If list.json doesn't exist, generate list
            console.warn('Could not load list.json, using fallback list. Please run generate-list.js or generate-list.py');
            allProteins = generateProteinList();
        }
        
        filteredProteins = [...allProteins];
    } catch (error) {
        console.error('Error initializing proteins:', error);
        allProteins = generateProteinList();
        filteredProteins = [...allProteins];
    }
}

// Generate a placeholder list (you should replace this with actual data)
// Note: This is only a fallback. You should provide a list.json file with all protein names
function generateProteinList() {
    // Return only the default protein as fallback
    // The actual list should come from list.json generated by generate-list.js or generate-list.py
    return [DEFAULT_IMAGE];
}

// Setup event listeners
function setupEventListeners() {
    searchInput.addEventListener('input', handleSearchInput);
    searchInput.addEventListener('keydown', handleKeyDown);
    searchInput.addEventListener('focus', () => {
        // Show results when input is focused
        if (filteredProteins.length > 0) {
            displayResults();
            showResults();
        }
    });
    searchInput.addEventListener('blur', () => {
        // Delay hiding to allow click events
        setTimeout(() => {
            searchResults.classList.remove('active');
        }, 200);
    });
    
    // Prevent image drag
    proteinImage.addEventListener('dragstart', (e) => e.preventDefault());
}

// Handle search input with debouncing
function handleSearchInput(e) {
    const query = e.target.value.trim();
    
    clearTimeout(searchTimeout);
    
    searchTimeout = setTimeout(() => {
        if (query === '') {
            // Show all proteins when search is empty
            filteredProteins = [...allProteins];
            selectedIndex = -1;
            displayResults();
            showResults();
            return;
        }
        
        performSearch(query);
    }, DEBOUNCE_DELAY);
}

// Perform fuzzy search
function performSearch(query) {
    const lowerQuery = query.toLowerCase();
    
    filteredProteins = allProteins.filter(protein => {
        const lowerProtein = protein.toLowerCase();
        return lowerProtein.includes(lowerQuery) || 
               fuzzyMatch(lowerProtein, lowerQuery);
    });
    
    selectedIndex = -1;
    displayResults();
    showResults();
}

// Simple fuzzy match function
function fuzzyMatch(text, pattern) {
    let patternIdx = 0;
    for (let i = 0; i < text.length && patternIdx < pattern.length; i++) {
        if (text[i] === pattern[patternIdx]) {
            patternIdx++;
        }
    }
    return patternIdx === pattern.length;
}

// Display search results
// For performance with 10,000+ items, we render all items but use efficient DOM manipulation
function displayResults() {
    if (filteredProteins.length === 0) {
        searchResults.innerHTML = '<div class="search-result-item">No results found</div>';
        return;
    }
    
    const query = searchInput.value.trim().toLowerCase();
    const totalCount = filteredProteins.length;
    
    // Use document fragment for better performance
    const fragment = document.createDocumentFragment();
    
    // Render all items (browsers can handle 10,000+ DOM elements, especially simple ones)
    filteredProteins.forEach((protein, index) => {
        const highlighted = highlightMatch(protein, query);
        const item = document.createElement('div');
        item.className = `search-result-item ${index === selectedIndex ? 'selected' : ''}`;
        item.setAttribute('data-index', index);
        item.setAttribute('data-protein', protein);
        item.innerHTML = `<span class="gene-name">${highlighted}</span>`;
        
        // Add click listener
        item.addEventListener('click', () => {
            selectProtein(protein);
        });
        
        fragment.appendChild(item);
    });
    
    // Clear and append in one operation
    searchResults.innerHTML = '';
    searchResults.appendChild(fragment);
    
    // Scroll to selected item
    if (selectedIndex >= 0 && selectedIndex < filteredProteins.length) {
        const selectedItem = searchResults.querySelector(`[data-index="${selectedIndex}"]`);
        if (selectedItem) {
            // Use setTimeout to ensure DOM is updated
            setTimeout(() => {
                selectedItem.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
            }, 0);
        }
    }
}

// Highlight matching text
function highlightMatch(text, query) {
    if (!query) return text;
    
    const lowerText = text.toLowerCase();
    const lowerQuery = query.toLowerCase();
    const index = lowerText.indexOf(lowerQuery);
    
    if (index === -1) {
        // Fuzzy highlight - highlight matching characters
        let result = '';
        let queryIdx = 0;
        for (let i = 0; i < text.length; i++) {
            if (queryIdx < query.length && 
                lowerText[i] === lowerQuery[queryIdx]) {
                result += `<span class="highlight">${text[i]}</span>`;
                queryIdx++;
            } else {
                result += text[i];
            }
        }
        return result;
    }
    
    return text.substring(0, index) +
           `<span class="highlight">${text.substring(index, index + query.length)}</span>` +
           text.substring(index + query.length);
}

// Handle keyboard navigation
function handleKeyDown(e) {
    // If results are not shown, show them on arrow down
    if (!searchResults.classList.contains('active')) {
        if ((e.key === 'ArrowDown' || e.key === 'ArrowUp') && filteredProteins.length > 0) {
            e.preventDefault();
            displayResults();
            showResults();
            if (e.key === 'ArrowDown') {
                selectedIndex = 0;
            } else {
                selectedIndex = filteredProteins.length - 1;
            }
            displayResults();
            return;
        }
        if (e.key === 'Enter' && searchInput.value.trim()) {
            performSearch(searchInput.value.trim());
            showResults();
        }
        return;
    }
    
    if (filteredProteins.length === 0) {
        return;
    }
    
    switch (e.key) {
        case 'ArrowDown':
            e.preventDefault();
            selectedIndex = Math.min(selectedIndex + 1, filteredProteins.length - 1);
            displayResults();
            break;
            
        case 'ArrowUp':
            e.preventDefault();
            selectedIndex = Math.max(selectedIndex - 1, -1);
            displayResults();
            break;
            
        case 'Enter':
            e.preventDefault();
            if (selectedIndex >= 0 && selectedIndex < filteredProteins.length) {
                selectProtein(filteredProteins[selectedIndex]);
            } else if (filteredProteins.length > 0) {
                selectProtein(filteredProteins[0]);
            }
            break;
            
        case 'Escape':
            searchResults.classList.remove('active');
            selectedIndex = -1;
            break;
    }
}

// Show search results
function showResults() {
    if (filteredProteins.length > 0) {
        searchResults.classList.add('active');
    } else {
        searchResults.classList.remove('active');
    }
}

// Select and load protein image
function selectProtein(proteinName) {
    searchInput.value = proteinName;
    searchResults.classList.remove('active');
    selectedIndex = -1;
    loadImage(proteinName);
}

// Load default image
function loadDefaultImage() {
    loadImage(DEFAULT_IMAGE);
}

// Load protein image
function loadImage(proteinName) {
    const imagePath = `${IMAGE_FOLDER}/${proteinName}.png`;
    
    // Show loading
    loadingIndicator.classList.add('active');
    errorMessage.style.display = 'none';
    proteinImage.classList.remove('loaded');
    proteinImage.style.display = 'none';
    imageInfo.textContent = '';
    
    // Reset image to prevent caching issues
    proteinImage.src = '';
    proteinImage.removeAttribute('loading');
    
    // Set up timeout for mobile networks (30 seconds)
    let loadTimeout = setTimeout(() => {
        if (loadingIndicator.classList.contains('active')) {
            showError();
            console.error('Image load timeout:', imagePath);
        }
    }, 30000);
    
    // Clean up timeout helper
    const clearLoadTimeout = () => {
        if (loadTimeout) {
            clearTimeout(loadTimeout);
            loadTimeout = null;
        }
    };
    
    // Handle successful load
    const handleImageLoad = () => {
        clearLoadTimeout();
        loadingIndicator.classList.remove('active');
        proteinImage.classList.add('loaded');
        proteinImage.style.display = 'block';
        imageInfo.textContent = proteinName;
        proteinImage.onload = null;
        proteinImage.onerror = null;
    };
    
    // Handle load error
    const handleImageError = () => {
        clearLoadTimeout();
        showError();
        console.error('Image load error:', imagePath);
        proteinImage.onload = null;
        proteinImage.onerror = null;
    };
    
    // Set image attributes
    proteinImage.alt = `Protein visualization: ${proteinName}`;
    proteinImage.referrerPolicy = 'no-referrer-when-downgrade';
    
    // Try loading with crossOrigin first (for CORS), fallback to without if needed
    let loadAttempt = 0;
    const maxAttempts = 2;
    
    // Enhanced error handler that retries without CORS
    const enhancedErrorHandler = () => {
        loadAttempt++;
        if (loadAttempt < maxAttempts) {
            // Retry without crossOrigin
            proteinImage.removeAttribute('crossorigin');
            proteinImage.src = imagePath + '?t=' + Date.now();
        } else {
            // Final failure
            handleImageError();
        }
    };
    
    // Set up event handlers before setting src
    proteinImage.onload = handleImageLoad;
    proteinImage.onerror = enhancedErrorHandler;
    
    // First attempt: try with crossOrigin (may not be needed, but helps with CORS)
    try {
        proteinImage.crossOrigin = 'anonymous';
    } catch (e) {
        // Ignore if crossOrigin not supported
    }
    
    // Load image directly (simplified for mobile compatibility)
    proteinImage.src = imagePath;
    
    // Check if image is already cached and loaded
    if (proteinImage.complete && proteinImage.naturalWidth > 0) {
        handleImageLoad();
    }
}

// Show error message
function showError() {
    loadingIndicator.classList.remove('active');
    errorMessage.style.display = 'block';
    proteinImage.classList.remove('loaded');
    imageInfo.textContent = '';
}
